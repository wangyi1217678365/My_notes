## 事件循环（Event Loop）

### 进程与线程

1. 进程、线程：一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；
2. 多进程、多线程：  
   1. 多进程：在同一个时间里，同一个计算机系统中允许两个或两个以上的进程处于运行状态。软件的进程之间丝毫不会相互干扰。
   2. 多线程：程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务。
> 以Chrome浏览器中为例，当你打开一个 Tab 页时，其实就是创建了一个进程，一个进程中可以有多个线程（下文会详细介绍），比如渲染线程、JS 引擎线程、HTTP 请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁。

### 浏览器内核
简单来说浏览器内核是通过取得页面内容、整理信息（应用CSS）、计算和组合最终输出可视化的图像结果，通常也被称为渲染引擎。  
浏览器内核是多线程，在内核控制下各线程相互配合以保持同步，一个浏览器通常由以下常驻线程组成：
- GUI 渲染线程
- JavaScript引擎线程
- 定时触发器线程
- 事件触发线程
- 异步http请求线程
  
1. GUI渲染线程
   - 主要负责页面的渲染，解析HTML、CSS，构建DOM树，布局和绘制等。
   - 当界面需要重绘或者由于某种操作引发回流时，将执行该线程。
   - 该线程与JS引擎线程互斥，当执行JS引擎线程时，GUI渲染会被挂起，当任务队列空闲时，主线程才会去执行GUI渲染。

2. JS引擎线程
   - 该线程当然是主要负责处理 JavaScript脚本，执行代码。
   - 也是主要负责执行准备好待执行的事件，即定时器计数结束，或者异步请求成功并正确返回时，将依次进入任务队列，等待 JS引擎线程的执行。
   - 当然，该线程与 GUI渲染线程互斥，当 JS引擎线程执行 JavaScript脚本时间过长，将导致页面渲染的阻塞。

3. 定时器触发线程
   - 负责执行异步定时器一类的函数的线程，如： setTimeout，setInterval。
   - 主线程依次执行代码时，遇到定时器，会将定时器交给该线程处理，当计数完毕后，事件触发线程会将计数完毕后的事件加入到任务队列的尾部，等待JS引擎线程执行。

4. 事件触发线程
   - 主要负责将准备好的事件交给 JS引擎线程执行。
   > 比如 setTimeout定时器计数结束， ajax等异步请求成功并触发回调函数，或者用户触发点击事件时，该线程会将整装待发的事件依次加入到任务队列的队尾，等待 JS引擎线程的执行。

5. 异步http请求线程
   - 负责执行异步请求一类的函数的线程，如： Promise，axios，ajax等。
   - 主线程依次执行代码时，遇到异步请求，会将函数交给该线程处理，当监听到状态码变更，如果有回调函数，事件触发线程会将回调函数加入到任务队列的尾部，等待JS引擎线程执行。

### Event Loop
一个完整的 Event Loop 过程，可以概括为以下阶段：  
![Event Loop 图解](./img/Event_Loop.awebp)
1. Micro-Task（微任务） 与 Macro-Task（宏任务）
浏览器端事件循环中的异步队列有两种：macro（宏任务）队列和 micro（微任务）队列。宏任务队列可以有多个，微任务队列只有一个。  
    **macro-task: setTimeout、setInterval、script（整体代码）、 I/O 操作、UI 渲染等。**  
    **micro-task: new Promise().then(回调)、MutationObserver(html5新特性) 等。** 
1. Event Loop 过程解析
- 一开始执行栈空,我们可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则。micro 队列空，macro 队列里有且只有一个 script 脚本（整体代码）。
- 全局上下文（script 标签）被推入执行栈，代码执行。在执行的过程中，会判断是同步任务还是异步任务，通过对一些接口的调用，可以产生新的 macro-task 与 micro-task，它们会分别被推入各自的任务队列里。如果中途有函数发生调用，将会创建一个新的函数执行上下文并放入当前执行栈的顶部并执行。同步代码执行完了，script 脚本会被移出执行栈，这个过程本质上是队列的 macro-task 的执行和出栈的过程。
- 上一步我们出队的是一个 macro-task，这一步我们处理的是 micro-task。但需要注意的是：当 macro-task 出队时，任务是一个一个执行的；而 micro-task 出队时，任务是一队一队执行的。因此，我们处理 micro 队列这一步，会逐个执行队列中的任务并把它出队，直到队列被清空。
- 微任务队列清空后，会将宏任务队列中排在最前面的任务，放入执行栈中执行，以此类推重复操作。
- 当执行站为空时会先去微任务队列中查找是否有任务有回调函数，如果有就加入到执行栈中执行，如果没有就将宏任务队列中的头部任务加入到执行栈中执行，如果宏任务队列中有计时器触发，那么就将该任务添加到执行栈顶部执行。